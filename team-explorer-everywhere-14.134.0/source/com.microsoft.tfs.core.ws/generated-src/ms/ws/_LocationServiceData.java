// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See License.txt in the repository root.

 /*
 * This file was automatically generated by com.microsoft.tfs.core.ws.generator.Generator
 * from the /complexType.vm template.
 */
package ms.ws;

import com.microsoft.tfs.core.ws.runtime.*;
import com.microsoft.tfs.core.ws.runtime.serialization.*;
import com.microsoft.tfs.core.ws.runtime.types.*;
import com.microsoft.tfs.core.ws.runtime.util.*;
import com.microsoft.tfs.core.ws.runtime.xml.*;

import ms.ws._AccessMapping;
import ms.ws._LocationMapping;
import ms.ws._LocationServiceData;
import ms.ws._ServiceDefinition;

import java.lang.String;

import java.util.ArrayList;
import java.util.List;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

/**
 * Automatically generated complex type class.
 */
public class _LocationServiceData
    implements ElementSerializable, ElementDeserializable
{
    // Attributes
    protected String defaultAccessMappingMoniker;
    protected int lastChangeId;
    protected boolean clientCacheFresh;
    protected boolean accessPointsDoNotIncludeWebAppRelativeDirectory;

    // Elements
    protected _ServiceDefinition[] serviceDefinitions;
    protected _AccessMapping[] accessMappings;

    public _LocationServiceData()
    {
        super();
    }

    public _LocationServiceData(
        final String defaultAccessMappingMoniker,
        final int lastChangeId,
        final boolean clientCacheFresh,
        final boolean accessPointsDoNotIncludeWebAppRelativeDirectory,
        final _ServiceDefinition[] serviceDefinitions,
        final _AccessMapping[] accessMappings)
    {
        // TODO : Call super() instead of setting all fields directly?
        setDefaultAccessMappingMoniker(defaultAccessMappingMoniker);
        setLastChangeId(lastChangeId);
        setClientCacheFresh(clientCacheFresh);
        setAccessPointsDoNotIncludeWebAppRelativeDirectory(accessPointsDoNotIncludeWebAppRelativeDirectory);
        setServiceDefinitions(serviceDefinitions);
        setAccessMappings(accessMappings);
    }

    public String getDefaultAccessMappingMoniker()
    {
        return this.defaultAccessMappingMoniker;
    }

    public void setDefaultAccessMappingMoniker(final String value)
    {
        this.defaultAccessMappingMoniker = value;
    }

    public int getLastChangeId()
    {
        return this.lastChangeId;
    }

    public void setLastChangeId(final int value)
    {
        this.lastChangeId = value;
    }

    public boolean isClientCacheFresh()
    {
        return this.clientCacheFresh;
    }

    public void setClientCacheFresh(final boolean value)
    {
        this.clientCacheFresh = value;
    }

    public boolean isAccessPointsDoNotIncludeWebAppRelativeDirectory()
    {
        return this.accessPointsDoNotIncludeWebAppRelativeDirectory;
    }

    public void setAccessPointsDoNotIncludeWebAppRelativeDirectory(final boolean value)
    {
        this.accessPointsDoNotIncludeWebAppRelativeDirectory = value;
    }

    public _ServiceDefinition[] getServiceDefinitions()
    {
        return this.serviceDefinitions;
    }

    public void setServiceDefinitions(_ServiceDefinition[] value)
    {
        this.serviceDefinitions = value;
    }

    public _AccessMapping[] getAccessMappings()
    {
        return this.accessMappings;
    }

    public void setAccessMappings(_AccessMapping[] value)
    {
        this.accessMappings = value;
    }

    public void writeAsElement(
        final XMLStreamWriter writer,
        final String name)
        throws XMLStreamException
    {
        writer.writeStartElement(name);

        // Attributes
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "DefaultAccessMappingMoniker",
            this.defaultAccessMappingMoniker);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "LastChangeId",
            this.lastChangeId);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "ClientCacheFresh",
            this.clientCacheFresh);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "AccessPointsDoNotIncludeWebAppRelativeDirectory",
            this.accessPointsDoNotIncludeWebAppRelativeDirectory);

        // Elements
        if (this.serviceDefinitions != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement("ServiceDefinitions");

            for (int iterator0 = 0; iterator0 < this.serviceDefinitions.length; iterator0++)
            {
                this.serviceDefinitions[iterator0].writeAsElement(
                    writer,
                    "ServiceDefinition");
            }

            writer.writeEndElement();
        }

        if (this.accessMappings != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement("AccessMappings");

            for (int iterator0 = 0; iterator0 < this.accessMappings.length; iterator0++)
            {
                this.accessMappings[iterator0].writeAsElement(
                    writer,
                    "AccessMapping");
            }

            writer.writeEndElement();
        }

        writer.writeEndElement();
    }

    public void readFromElement(final XMLStreamReader reader)
        throws XMLStreamException
    {
        String localName;

        // Attributes
        final int attributeCount = reader.getAttributeCount();
        String attributeValue;

        for (int i = 0; i < attributeCount; i++)
        {
            localName = reader.getAttributeLocalName(i);
            attributeValue = reader.getAttributeValue(i);

            if (localName.equalsIgnoreCase("DefaultAccessMappingMoniker"))
            {
                this.defaultAccessMappingMoniker = attributeValue;
            }
            else if (localName.equalsIgnoreCase("LastChangeId"))
            {
                this.lastChangeId = XMLConvert.toInt(attributeValue);
            }
            else if (localName.equalsIgnoreCase("ClientCacheFresh"))
            {
                this.clientCacheFresh = XMLConvert.toBoolean(attributeValue);
            }
            else if (localName.equalsIgnoreCase("AccessPointsDoNotIncludeWebAppRelativeDirectory"))
            {
                this.accessPointsDoNotIncludeWebAppRelativeDirectory = XMLConvert.toBoolean(attributeValue);
            }

            // Ignore unknown attributes.
        }

        // Elements
        int event;

        do
        {
            event = reader.next();

            if (event == XMLStreamConstants.START_ELEMENT)
            {
                localName = reader.getLocalName();

                if (localName.equalsIgnoreCase("ServiceDefinitions"))
                {
                    /*
                     * The element type is an array.
                     */
                    int event0;
                    final List list0 = new ArrayList();

                    do
                    {
                        event0 = reader.nextTag();

                        if (event0 == XMLStreamConstants.START_ELEMENT)
                        {
                            _ServiceDefinition complexObject0 = new _ServiceDefinition();
                            complexObject0.readFromElement(reader);
                            list0.add(complexObject0);
                        }
                    }
                    while (event0 != XMLStreamConstants.END_ELEMENT);

                    this.serviceDefinitions = (_ServiceDefinition[]) list0.toArray(
                            new _ServiceDefinition[list0.size()]);
                }
                else if (localName.equalsIgnoreCase("AccessMappings"))
                {
                    /*
                     * The element type is an array.
                     */
                    int event0;
                    final List list0 = new ArrayList();

                    do
                    {
                        event0 = reader.nextTag();

                        if (event0 == XMLStreamConstants.START_ELEMENT)
                        {
                            _AccessMapping complexObject0 = new _AccessMapping();
                            complexObject0.readFromElement(reader);
                            list0.add(complexObject0);
                        }
                    }
                    while (event0 != XMLStreamConstants.END_ELEMENT);

                    this.accessMappings = (_AccessMapping[]) list0.toArray(new _AccessMapping[list0.size()]);
                }
                else
                {
                    // Read the unknown child element until its end
                    XMLStreamReaderHelper.readUntilElementEnd(reader);
                }
            }
        }
        while (event != XMLStreamConstants.END_ELEMENT);
    }
}
