// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See License.txt in the repository root.

 /*
 * This file was automatically generated by com.microsoft.tfs.core.ws.generator.Generator
 * from the /complexType.vm template.
 */
package ms.tfs.versioncontrol.clientservices._03;

import com.microsoft.tfs.core.ws.runtime.*;
import com.microsoft.tfs.core.ws.runtime.serialization.*;
import com.microsoft.tfs.core.ws.runtime.types.*;
import com.microsoft.tfs.core.ws.runtime.util.*;
import com.microsoft.tfs.core.ws.runtime.xml.*;

import ms.tfs.versioncontrol.clientservices._03._WorkingFolder;
import ms.tfs.versioncontrol.clientservices._03._WorkingFolderType;
import ms.tfs.versioncontrol.clientservices._03._Workspace;

import java.lang.String;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

/**
 * Automatically generated complex type class.
 */
public class _Workspace
    implements ElementSerializable, ElementDeserializable
{
    // Attributes
    protected String computer;
    protected boolean islocal;
    protected String name;
    protected String owner;
    protected String ownerdisp;
    protected String owneruniq;
    protected int permissions = 0;
    protected String securitytoken;
    protected String ownertype;
    protected String ownerid;

    // Elements
    protected String comment;
    protected _WorkingFolder[] folders;
    protected String[] ownerAliases;
    protected Calendar lastAccessDate;
    protected int options = 0;

    public _Workspace()
    {
        super();
    }

    public _Workspace(
        final String computer,
        final boolean islocal,
        final String name,
        final String owner,
        final String ownerdisp,
        final String owneruniq,
        final int permissions,
        final String securitytoken,
        final String ownertype,
        final String ownerid,
        final String comment,
        final _WorkingFolder[] folders,
        final String[] ownerAliases,
        final Calendar lastAccessDate,
        final int options)
    {
        // TODO : Call super() instead of setting all fields directly?
        setComputer(computer);
        setIslocal(islocal);
        setName(name);
        setOwner(owner);
        setOwnerdisp(ownerdisp);
        setOwneruniq(owneruniq);
        setPermissions(permissions);
        setSecuritytoken(securitytoken);
        setOwnertype(ownertype);
        setOwnerid(ownerid);
        setComment(comment);
        setFolders(folders);
        setOwnerAliases(ownerAliases);
        setLastAccessDate(lastAccessDate);
        setOptions(options);
    }

    public String getComputer()
    {
        return this.computer;
    }

    public void setComputer(final String value)
    {
        this.computer = value;
    }

    public boolean isIslocal()
    {
        return this.islocal;
    }

    public void setIslocal(final boolean value)
    {
        this.islocal = value;
    }

    public String getName()
    {
        return this.name;
    }

    public void setName(final String value)
    {
        this.name = value;
    }

    public String getOwner()
    {
        return this.owner;
    }

    public void setOwner(final String value)
    {
        this.owner = value;
    }

    public String getOwnerdisp()
    {
        return this.ownerdisp;
    }

    public void setOwnerdisp(final String value)
    {
        this.ownerdisp = value;
    }

    public String getOwneruniq()
    {
        return this.owneruniq;
    }

    public void setOwneruniq(final String value)
    {
        this.owneruniq = value;
    }

    public int getPermissions()
    {
        return this.permissions;
    }

    public void setPermissions(final int value)
    {
        this.permissions = value;
    }

    public String getSecuritytoken()
    {
        return this.securitytoken;
    }

    public void setSecuritytoken(final String value)
    {
        this.securitytoken = value;
    }

    public String getOwnertype()
    {
        return this.ownertype;
    }

    public void setOwnertype(final String value)
    {
        this.ownertype = value;
    }

    public String getOwnerid()
    {
        return this.ownerid;
    }

    public void setOwnerid(final String value)
    {
        this.ownerid = value;
    }

    public String getComment()
    {
        return this.comment;
    }

    public void setComment(String value)
    {
        this.comment = value;
    }

    public _WorkingFolder[] getFolders()
    {
        return this.folders;
    }

    public void setFolders(_WorkingFolder[] value)
    {
        this.folders = value;
    }

    public String[] getOwnerAliases()
    {
        return this.ownerAliases;
    }

    public void setOwnerAliases(String[] value)
    {
        this.ownerAliases = value;
    }

    public Calendar getLastAccessDate()
    {
        return this.lastAccessDate;
    }

    public void setLastAccessDate(Calendar value)
    {
        if (value == null)
        {
            throw new IllegalArgumentException("'LastAccessDate' is a required element, its value cannot be null");
        }

        this.lastAccessDate = value;
    }

    public int getOptions()
    {
        return this.options;
    }

    public void setOptions(int value)
    {
        this.options = value;
    }

    public void writeAsElement(
        final XMLStreamWriter writer,
        final String name)
        throws XMLStreamException
    {
        writer.writeStartElement(name);

        // Attributes
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "computer",
            this.computer);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "islocal",
            this.islocal);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "name",
            this.name);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "owner",
            this.owner);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "ownerdisp",
            this.ownerdisp);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "owneruniq",
            this.owneruniq);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "permissions",
            this.permissions);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "securitytoken",
            this.securitytoken);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "ownertype",
            this.ownertype);
        XMLStreamWriterHelper.writeAttribute(
            writer,
            "ownerid",
            this.ownerid);

        // Elements
        XMLStreamWriterHelper.writeElement(
            writer,
            "Comment",
            this.comment);

        if (this.folders != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement("Folders");

            for (int iterator0 = 0; iterator0 < this.folders.length; iterator0++)
            {
                this.folders[iterator0].writeAsElement(
                    writer,
                    "WorkingFolder");
            }

            writer.writeEndElement();
        }

        if (this.ownerAliases != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement("OwnerAliases");

            for (int iterator0 = 0; iterator0 < this.ownerAliases.length; iterator0++)
            {
                XMLStreamWriterHelper.writeElement(
                    writer,
                    "string",
                    this.ownerAliases[iterator0]);
            }

            writer.writeEndElement();
        }

        XMLStreamWriterHelper.writeElement(
            writer,
            "LastAccessDate",
            this.lastAccessDate,
            true);
        XMLStreamWriterHelper.writeElement(
            writer,
            "Options",
            this.options);

        writer.writeEndElement();
    }

    public void readFromElement(final XMLStreamReader reader)
        throws XMLStreamException
    {
        String localName;

        // Attributes
        final int attributeCount = reader.getAttributeCount();
        String attributeValue;

        for (int i = 0; i < attributeCount; i++)
        {
            localName = reader.getAttributeLocalName(i);
            attributeValue = reader.getAttributeValue(i);

            if (localName.equalsIgnoreCase("computer"))
            {
                this.computer = attributeValue;
            }
            else if (localName.equalsIgnoreCase("islocal"))
            {
                this.islocal = XMLConvert.toBoolean(attributeValue);
            }
            else if (localName.equalsIgnoreCase("name"))
            {
                this.name = attributeValue;
            }
            else if (localName.equalsIgnoreCase("owner"))
            {
                this.owner = attributeValue;
            }
            else if (localName.equalsIgnoreCase("ownerdisp"))
            {
                this.ownerdisp = attributeValue;
            }
            else if (localName.equalsIgnoreCase("owneruniq"))
            {
                this.owneruniq = attributeValue;
            }
            else if (localName.equalsIgnoreCase("permissions"))
            {
                this.permissions = XMLConvert.toInt(attributeValue);
            }
            else if (localName.equalsIgnoreCase("securitytoken"))
            {
                this.securitytoken = attributeValue;
            }
            else if (localName.equalsIgnoreCase("ownertype"))
            {
                this.ownertype = attributeValue;
            }
            else if (localName.equalsIgnoreCase("ownerid"))
            {
                this.ownerid = attributeValue;
            }

            // Ignore unknown attributes.
        }

        // Elements
        int event;

        do
        {
            event = reader.next();

            if (event == XMLStreamConstants.START_ELEMENT)
            {
                localName = reader.getLocalName();

                if (localName.equalsIgnoreCase("Comment"))
                {
                    this.comment = reader.getElementText();
                }
                else if (localName.equalsIgnoreCase("Folders"))
                {
                    /*
                     * The element type is an array.
                     */
                    int event0;
                    final List list0 = new ArrayList();

                    do
                    {
                        event0 = reader.nextTag();

                        if (event0 == XMLStreamConstants.START_ELEMENT)
                        {
                            _WorkingFolder complexObject0 = new _WorkingFolder();
                            complexObject0.readFromElement(reader);
                            list0.add(complexObject0);
                        }
                    }
                    while (event0 != XMLStreamConstants.END_ELEMENT);

                    this.folders = (_WorkingFolder[]) list0.toArray(new _WorkingFolder[list0.size()]);
                }
                else if (localName.equalsIgnoreCase("OwnerAliases"))
                {
                    /*
                     * The element type is an array.
                     */
                    int event0;
                    final List list0 = new ArrayList();

                    do
                    {
                        event0 = reader.nextTag();

                        if (event0 == XMLStreamConstants.START_ELEMENT)
                        {
                            list0.add(reader.getElementText());
                        }
                    }
                    while (event0 != XMLStreamConstants.END_ELEMENT);

                    this.ownerAliases = (String[]) list0.toArray(new String[list0.size()]);
                }
                else if (localName.equalsIgnoreCase("LastAccessDate"))
                {
                    this.lastAccessDate = XMLConvert.toCalendar(
                            reader.getElementText(),
                            true);
                }
                else if (localName.equalsIgnoreCase("Options"))
                {
                    this.options = XMLConvert.toInt(reader.getElementText());
                }
                else
                {
                    // Read the unknown child element until its end
                    XMLStreamReaderHelper.readUntilElementEnd(reader);
                }
            }
        }
        while (event != XMLStreamConstants.END_ELEMENT);
    }
}
